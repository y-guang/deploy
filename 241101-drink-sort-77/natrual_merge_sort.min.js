class NaturalMergeSort{constructor(e){if(!Array.isArray(e))throw new Error("NaturalMergeSort: input should be an array");this.array=e,this.mergeStack=[],this.merging=[],this.phase=0,this.find_list=[this.array[0]],this.find_i=1,this.array.length<2&&(this.mergeStack=[[...this.array]],this.phase=2)}next(){switch(this.phase){case 0:return{left:this.find_list[this.find_list.length-1],right:this.array[this.find_i]};case 1:let e=this.merging[0];return{left:e.left[e.left_i],right:e.right[e.right_i]};case 2:throw new Error("NaturalMergeSort: calling next() after finished")}}_handle_merging(e){let t=this.merging.shift();return t.left_i<t.left.length&&t.right_i<t.right.length&&(e?(t.merged.push(t.left[t.left_i]),t.left_i++):(t.merged.push(t.right[t.right_i]),t.right_i++)),t.left_i>=t.left.length?(t.merged=t.merged.concat(t.right.slice(t.right_i)),this.mergeStack.push(t.merged),!0):t.right_i>=t.right.length?(t.merged=t.merged.concat(t.left.slice(t.left_i)),this.mergeStack.push(t.merged),!0):(this.merging.push(t),!1)}_handle_merge_stack(){for(;this.mergeStack.length>1;){let e=this.mergeStack.shift(),t=this.mergeStack.shift(),i={left:e,right:t,left_i:0,right_i:0,merged:[]};this.merging.push(i)}}firstIsSmallerOrEqual(e){switch(this.phase){case 0:e?(this.find_list.push(this.array[this.find_i]),this.find_i++):(this.mergeStack.push(this.find_list),this.find_list=[this.array[this.find_i]],this.find_i++),this.find_i>=this.array.length&&(this.mergeStack.push(this.find_list),this.phase=1,this._handle_merge_stack(),this.mergeStack.length===1&&this.merging.length===0&&(this.phase=2));break;case 1:if(this.merging.length>0){let t=this._handle_merging(e);this._handle_merge_stack()}this.mergeStack.length===1&&this.merging.length===0&&(this.phase=2);break;case 2:throw new Error(`NaturalMergeSort: calling firstIsSmallerOrEqual(${e}) after finished`)}}get finished(){return this.phase===2}get result(){if(this.phase===2)return[...this.mergeStack[0]];throw new Error("NaturalMergeSort: calling result before finished")}}
